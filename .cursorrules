# Universal Cursor Rules for Development

## General Development Guidelines

### Code Quality & Style
- Write clean, readable, and maintainable code
- Use consistent naming conventions (camelCase for variables/functions, PascalCase for classes)
- Follow the principle of least surprise - code should do what it appears to do
- Prefer explicit over implicit code
- Use meaningful variable and function names that describe their purpose
- Keep functions small and focused on a single responsibility
- Avoid deep nesting - prefer early returns and guard clauses

### File Organization & Structure
- Organize files logically by feature/module rather than by file type
- Use consistent directory structure throughout the project
- Group related files together
- Keep configuration files at the root level
- Use descriptive file and folder names
- Avoid deeply nested directory structures (max 3-4 levels)

### Import/Dependency Management
- Organize imports in a consistent order:
  1. Standard library imports
  2. Third-party library imports
  3. Local/internal imports
- Use absolute imports when possible to avoid relative path confusion
- Remove unused imports regularly
- Group related imports together
- Use explicit imports rather than wildcard imports when possible

### Documentation & Comments
- Write self-documenting code that doesn't need excessive comments
- Add comments for complex business logic or non-obvious implementations
- Use JSDoc/docstrings for public APIs and complex functions
- Keep README files up-to-date with setup and usage instructions
- Document breaking changes and migration guides
- Include examples in documentation

### Error Handling
- Handle errors gracefully and provide meaningful error messages
- Use appropriate error types for different scenarios
- Log errors with sufficient context for debugging
- Don't swallow exceptions - handle them appropriately
- Validate inputs at system boundaries
- Use consistent error response formats across the application

### Testing
- Write tests for all critical functionality
- Follow the testing pyramid (unit > integration > e2e)
- Use descriptive test names that explain what is being tested
- Arrange-Act-Assert pattern for test structure
- Mock external dependencies in unit tests
- Test both success and failure scenarios
- Aim for high test coverage but focus on meaningful tests

### Performance & Optimization
- Optimize for readability first, performance second
- Profile before optimizing - don't guess at bottlenecks
- Use appropriate data structures for the task
- Avoid premature optimization
- Cache expensive operations when appropriate
- Use lazy loading for large datasets
- Minimize network requests and database queries

### Security Best Practices
- Validate all user inputs
- Use parameterized queries to prevent injection attacks
- Store sensitive data securely (environment variables, secrets management)
- Implement proper authentication and authorization
- Use HTTPS in production
- Keep dependencies updated
- Follow the principle of least privilege
- Sanitize outputs to prevent XSS

### Version Control & Git
- Write clear, descriptive commit messages
- Use conventional commit format when possible
- Make small, focused commits
- Use feature branches for development
- Write meaningful pull request descriptions
- Keep the main branch stable and deployable
- Tag releases appropriately

### Environment & Configuration
- Use environment variables for configuration
- Never commit secrets or sensitive data
- Provide example configuration files
- Use different configurations for different environments
- Validate configuration at startup
- Document all configuration options

### Code Review Guidelines
- Review for logic correctness and edge cases
- Check for security vulnerabilities
- Ensure code follows project conventions
- Verify tests are comprehensive
- Look for opportunities to simplify or improve performance
- Provide constructive feedback
- Approve only when confident in the changes

### Database & Data Management
- Use appropriate indexes for query performance
- Implement proper data validation
- Use transactions for multi-step operations
- Design normalized database schemas
- Implement proper backup and recovery procedures
- Use migrations for schema changes
- Document data models and relationships

### API Design (if applicable)
- Follow RESTful principles
- Use appropriate HTTP methods and status codes
- Implement consistent response formats
- Version your APIs appropriately
- Document API endpoints thoroughly
- Implement proper rate limiting
- Use pagination for large datasets

### Logging & Monitoring
- Log at appropriate levels (debug, info, warn, error)
- Include contextual information in logs
- Don't log sensitive information
- Use structured logging when possible
- Implement health checks
- Monitor application performance and errors
- Set up alerts for critical issues

### Dependency Management
- Keep dependencies up-to-date
- Regularly audit dependencies for security vulnerabilities
- Use lock files to ensure consistent builds
- Minimize the number of dependencies
- Choose well-maintained libraries
- Document reasons for major dependency choices

### Code Formatting & Linting
- Use automated code formatting tools
- Configure linting rules and enforce them
- Set up pre-commit hooks for quality checks
- Use consistent indentation and spacing
- Follow language-specific style guides
- Configure IDE/editor for consistent formatting

### Accessibility (for web applications)
- Use semantic HTML elements
- Provide alternative text for images
- Ensure keyboard navigation works
- Use appropriate color contrast
- Test with screen readers
- Follow WCAG guidelines

### Internationalization (if applicable)
- Externalize user-facing strings
- Use proper date/time formatting
- Handle different number formats
- Consider right-to-left languages
- Test with different locales
- Plan for text expansion in translations

### Deployment & DevOps
- Use infrastructure as code
- Implement automated testing in CI/CD
- Use blue-green or rolling deployments
- Monitor application health in production
- Implement proper backup strategies
- Use containerization for consistent environments
- Document deployment procedures

### Maintenance & Refactoring
- Regularly refactor code to improve quality
- Remove dead code and unused features
- Update documentation when code changes
- Plan for technical debt reduction
- Monitor and improve performance over time
- Keep dependencies and frameworks updated

## Language-Specific Guidelines

### JavaScript/TypeScript
- Use TypeScript for better type safety
- Prefer const/let over var
- Use arrow functions appropriately
- Implement proper error boundaries
- Use async/await over promises when possible
- Avoid callback hell

### Python
- Follow PEP 8 style guide
- Use virtual environments
- Write docstrings for modules, classes, and functions
- Use type hints for better code documentation
- Handle exceptions appropriately
- Use list comprehensions judiciously

### Java
- Follow Oracle's Java conventions
- Use appropriate design patterns
- Implement proper exception handling
- Use generics for type safety
- Write comprehensive unit tests
- Use dependency injection

### C#
- Follow Microsoft's C# conventions
- Use LINQ appropriately
- Implement proper disposal patterns
- Use async/await for I/O operations
- Write XML documentation
- Use nullable reference types

## Framework-Specific Guidelines

### React
- Use functional components with hooks
- Implement proper state management
- Use React.memo for performance optimization
- Write reusable components
- Handle side effects properly
- Use proper key props for lists

### Angular
- Follow Angular style guide
- Use TypeScript strictly
- Implement proper dependency injection
- Use reactive forms
- Write unit tests for components and services
- Use OnPush change detection strategy

### Vue.js
- Use composition API for new components
- Implement proper component communication
- Use Vuex/Pinia for state management
- Write single-file components
- Use proper lifecycle hooks
- Implement proper error handling

### Node.js
- Use modern JavaScript features
- Implement proper error handling
- Use streams for large data processing
- Implement proper security measures
- Use clustering for CPU-intensive tasks
- Monitor memory usage

## Best Practices Summary

1. **Clarity over cleverness** - Write code that others can understand
2. **Fail fast** - Validate inputs and catch errors early
3. **DRY (Don't Repeat Yourself)** - But don't abstract too early
4. **YAGNI (You Aren't Gonna Need It)** - Don't build features you don't need
5. **SOLID principles** - Write maintainable object-oriented code
6. **Test-driven development** - Write tests first when appropriate
7. **Continuous improvement** - Regularly refactor and improve code quality
8. **Security by design** - Consider security implications from the start
9. **Performance awareness** - Write efficient code without premature optimization
10. **Documentation as code** - Keep documentation close to the code it describes

Remember: These are guidelines, not rigid rules. Use judgment to apply them appropriately to your specific project and context. 